%\documentclass[a4paper,11pt]{article}%JHEP%
%\pdfoutput=1 % if your are submitting a pdflatex (i.e. if you have
             % images in pdf, png or jpg format)%JHEP%

%\usepackage{jheppub} % for details on the use of the package, please
                     % see the JHEP-author-manual%JHEP%

\documentclass[aps,prd,nofootinbib,preprint]{revtex4}

\usepackage[T1]{fontenc} % if needed
\usepackage{amsmath}
\usepackage{leftidx}
\usepackage{multirow}
\usepackage{enumerate}
%\usepackage{textcomp}

%\usepackage{underscore}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\usepackage[nottoc]{tocbibind}

\usepackage{hyperref}
%\usepackage{ulem}
\usepackage{color}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{amsmath,amssymb,amsthm,amsxtra,overpic,bbm,bm,float
,epsfig}



%JHEP%
%\title{\boldmath  Flavour Symmetry Embedded - GLoBES (FaSE-GLoBES)}


%JHEP%
%\author[a]{Jian Tang,}
%\author[a]{Tse-Chun Wang}
%\affiliation[a]{School of Physics, Sun Yat-Sen University, Guangzhou 510275, China}
%\emailAdd{tangjian5@mail.sysu.edu.cn}
%\emailAdd{wangzejun@mail.sysu.edu.cn}
%\abstract{Abstract...}


%\fontsize{3}{5}\selectfont
\begin{document} 
%\title{The user manual: FlAvour Symmetry with the GLoBES library}
%\title{FlAvour Symmetry with the GLoBES library}
\title{Flavour Symmetry Embedded - GLoBES (FaSE-GLoBES)} %JHEP%
%\maketitle %JHEP%
%\flushbottom %JHEP%
\author{Jian Tang$^1$\footnote{tangjian5@mail.sysu.edu.cn}}
\author{Tse-Chun Wang$^1$\footnote{wangzejun@mail.sysu.edu.cn}}
\affiliation{$^1$School of Physics, Sun Yat-Sen University, Guangzhou 510275, China}

\begin{abstract}
\textbf{Keywords: Neutrino Oscillations, Leptonic Flavour Symmetry}  
\end{abstract}

\maketitle

\section{Introduction}\label{sec:intro}

The discovery of neutrino oscillations points out the fact that neutrinos have mass, and provides evidence beyond the Standard Model (BSM). This phenomenon is successfully described by a theoretical framework with the help of three neutrino mixing angles ($\theta_{12}$, $\theta_{13}$, $\theta_{23}$), two mass-square splittings ($\Delta m_{21}^2$, $\Delta m_{31}^2$), and one Dirac CP phase ($\delta$) \cite{Pontecorvo:1967fh,Maki:1962mu,Pontecorvo:1957qd,Esteban:2018azc}. Thanks to the great efforts in the past two decades, we almost have a complete understanding of such a neutrino oscillation framework. More data in the neutrino oscillation experiments is needed to determine the sign of $\Delta m_{31}^2$, to measure the value of $\sin\theta_{23}$, to discover the potential CP violation in the leptonic sector and even to constrain the size of $\delta$ \cite{Esteban:2018azc}. For these purposes, the on-going long baseline experiments (LBLs), such as the NuMI Off-axis $\nu_e$ Appearance experiment (NO$\nu$A)~\cite{Ayres:2007tu} and the Tokai-to-Kamioka experiment (T2K)~\cite{Abe:2011ks}, can answer these questions with the statistical significance $\gtrsim 3\sigma$ in most of the parameter space. Based on the analysis with their data, the normal mass ordering ($\Delta m_{31}^2>0$), the higher $\theta_{23}$ octant ($\theta_{23}>45^\circ$), and $\delta\sim270^\circ$ are preferred so far~\cite{Esteban:2018azc}. The future LBLs, Deep Underground Neutrino Experiment (DUNE)~\cite{Acciarri:2015uup}, Tokai to Hyper-Kamiokande (T2HK)~\cite{Abe:2014oxa}, and the medium baseline reactor experiment, the Jiangmen Underground Neutrino Observatory (JUNO)~\cite{Djurcic:2015vqa,An:2015jdp} will further complete our knowledge of neutrino oscillations.

Flavour symmetry models are used to explain the origin of the neutrino mixing, and to predict the value of oscillation parameters (some of useful review articles are~\cite{Altarelli:2010gt,Ishimori:2010au,King:2013eh,King:2014nza,King:2015aea,King:2015ata,King:2017guk}). These models are motivated by some interesting features, \textit{such as} $\theta_{12}\sim 33^\circ$, and $\theta_{23}\sim 45^\circ$. Before the discovery of non-zero $\theta_{13}$ measurement by Daya Bay experiment~\cite{An:2013zwz}, the `tri-bi-maximal' neutrino mixing (TBM) ansatz, which was proposed in 2002 by Horrison, Perkins, and Scott~\cite{Harrison:2002er}, fitted with the experimental data in a good agreement:
\begin{equation*}
U_{\text{TBM}}=\left(
\begin{array}{ccc}
2/\sqrt{6} & 1/\sqrt{3} & 0\\
-1/\sqrt{6} & 1/\sqrt{3} & 1/\sqrt{2}\\
1/\sqrt{6}  & -1/\sqrt{3} & 1/\sqrt{2}
\end{array}\right).
\end{equation*} 
With the fact that $\theta_{13}\approx 8^\circ$, several ways to obtain such non-zero value of $\theta_{13}$ are proposed. One of popular proposals is to correct the tri-bi-maximal neutrino mixing such that 
\begin{equation*}
\sin\theta_{12}=(1+s)/\sqrt{3},~\sin\theta_{13}=r/\sqrt{2},~\text{and}~\sin\theta_{23}=(1+a)/\sqrt{2}.
\end{equation*}

Currently, some works discuss on how the future experiments can be used for testing these flavour symmetry models in the phenomenological point of view, \textit{e.g.}~Ref.~\cite{Ballett:2016yod,Chatterjee:2017xkb,Ding:2019zhn,Tang:2019edw}. A large number of these works are based on the \texttt{c}-library -- \textbf{G}eneral \textbf{Lo}ng \textbf{B}aseline \textbf{E}xperiment \textbf{S}imulator (\textbf{GLoBES}) \cite{Huber:2004ka,Huber:2007ji}, which is a convenient simulation tool to simulate neutrino oscillation experiments via the Abstract Experiment Definition Language (AEDL). Some AEDL files for experiments are also available on \textbf{GLoBES} website, while the working group of DUNE experiment also releases their AEDL files~\cite{Alion:2016uaj}.  \textbf{GLoBES} can be taken as one of popular and useful tools in the community of neutrino oscillation physics. However, it has not yet to be extended for the purpose of analysing flavour symmetry models.  In this work, we will present our simulation tool \textbf{F}l\textbf{a}vour \textbf{S}ymmetry \textbf{E}mbedded - \textbf{GLoBES} (\textbf{FaSE-GloBES}) that is a simulation code based on GLoBES library for studying the flavour symmetry. \textbf{FaSE} is a supplemental tool for GLoBES, written in \texttt{c/c++} language, and FASE-GLoBES allows the user to assign the flavour symmetry model and analysis how a flavour symmetry model can be excluded by the simulated neutrino oscillation experiment.




\section{Overview FASE-GloBES}

\textbf{F}l\textbf{a}vor \textbf{S}ymmetry \textbf{E}mbedded (\textbf{FaSE}) is a supplemental tool for General Long Baseline Experiment Simulator (\textbf{GLoBES}) in order to analysis how a leptonic flavour symmetry model can be tested in neutrino oscillation experiments. \textbf{FaSE} is written in the \texttt{c/c++} language, and consist with three codes \textbf{FASE\_GLoBES.c} and \textbf{model-input.c}. The user defines the model in to \textbf{model-input.c}, while \textbf{FASE\_GLoBES.c} does not need to be touched. 

\begin{figure}[!h]%
\centering
\includegraphics[width=4.5in]{Figs/FASE-chart_1_v1.pdf}
\caption{A scheme to correlate the model parameters with standard neutrino oscillation parameters. The error propagation is implemented in the simulation code up to the spectra analysis.}%
\label{fig:FASE}
\end{figure}


The concept of \textbf{FaSE-GLoBES} is shown in Fig.~\ref{fig:FASE}, in which three parts are shown: 1.~\textbf{the parameter translation} (the blue box), 2.~\textbf{giving oscillation-parameter values} (the green box), and 3.~\textbf{the $\chi^2$-value calculation} (the orange box). 
The idea behind this flow chart Fig.~\ref{fig:FASE} is that given a set of value for model parameter, the corresponding values for oscillation parameters are obtained by a translation, which is assigned by the user in \textbf{model-input.c}. And then, through \textbf{FASE\_GLoBES.c}, these oscillation-parameter values are passed in to \textbf{GLoBES} library to simulate the event spectrum for evaluating the $\chi^2$ value. 


API functions to use \textbf{FaSE} are listed:
\begin{enumerate}
\item \texttt{MODEL\_init($N_{para}$)},
\item  \texttt{FASE\_glb\_probability\_matrix},
\item  \texttt{FASE\_glb\_set\_oscillation\_parameters},
\item  \texttt{FASE\_glb\_get\_oscillation\_parameters},
\item \texttt{FASE\_prior\_OSC},
\item \texttt{FASE\_prior\_model}.
\end{enumerate}
The first one is to initialise \textbf{FaSE} with the parameter $N_{para}$ the number of input parameters. The next three functions need to be included to replace the default GLoBES probability engine by the one that can read the output from \textbf{model-input.c}, as follows\vspace{0.2cm}\\
\texttt{    glbRegisterProbabilityEngine(6,\\
                                 \&FASE\_glb\_probability\_matrix,\\
                                 \&FASE\_glb\_set\_oscillation\_parameters,\\
                                 \&FASE\_glb\_get\_oscillation\_parameters,\\
                                 NULL); }\vspace{0.2cm}\\ 
This probability engine can work with the oscillation or model parameter. It can be set by the user with the parameter \texttt{PARA}. If \texttt{PARA=STAN} (\texttt{PARA=MODEL}) the probability engine works with oscillation (model) parameters. The final two functions are prior functions. Once the user gives the prior in oscillation (model) parameters, the user needs to call \texttt{FASE\_prior\_OSC} (\texttt{FASE\_prior\_model}) as follows.\vspace{0.2cm}\\
\texttt{glbRegisterPriorFunction(FASE\_prior\_OSC,NULL,NULL,NULL); }  \\
or\\
\texttt{glbRegisterPriorFunction(FASE\_prior\_model,NULL,NULL,NULL); } \vspace{0.2cm}\\
We note that except for setting the probability engine and the prior function, the other parts in the main code should follow with the GLoBES manual. 


\section{Model setting}\label{sec:model_set}

In the function \texttt{MtoS} in \textbf{model-input.c}, the user can assign the relation between the oscillation and model parameter sets, or define the mass matrix in model parameters, which will be diagonalised by the function \texttt{ModelTO} to obtain the corresponding oscillation-parameter values.  The user needs give the input of \texttt{MtoS} -- a set of model parameters ($\vec{\theta}_{Model}$), and the output is the corresponding oscillation parameter $\vec{\theta}_{OSC.}$, of which components are $\theta_{12}$, $\theta_{13}$, $\theta_{23}$, $\delta$, $\Delta m_{21}^2$, and $\Delta m_{31}^2$. These values will be passed in to \textbf{FaSE\_GLoBES} to simulate 
the experimental spectra and compute the prior value.

The relation between the oscillation and model parameter sets can be derived out by the user, 
\begin{equation}
\vec{\theta}_{Model}=\vec{f}(\vec{\theta}_{OSC.})
\end{equation}
and give in the function \texttt{MtoS}.
%
The oscillation parameters are based on
\begin{equation}\label{eq:MM}
U^\dagger\mathcal{M}\mathcal{M}^\dagger U = \mathbf{M}^2,~\text{where}~\mathbf{M}^2_{\alpha\beta}=m_\alpha^2\delta_{\alpha\beta},
\end{equation}
where $\mathcal{M}$ ($\mathbf{M}$) is the mass matrix in the flavour (mass) state. The matrix $\mathcal{M}$ is given by user with model parameters ($\vec{\theta}_{Model}$). The matrix $U$ is the mixing matrix, and can be used for getting mixing angles, and the diagonal elements of $\textbf{M}$ are for the corresponding mass-squared differences. The diagnolisation will be done in the function \texttt{ModelTO}, which needs to be called in \texttt{MtoS}. The output is the vector of oscillation parameters, of which components are  $\theta_{12}$, $\theta_{13}$, $\theta_{23}$, $\delta$, $\Delta m_{21}^2$, and $\Delta m_{31}^2$. For the first four components, values are given in the unit of \textbf{rad}, while the other two are in \textbf{eV$^2$}.



\section{Prior setting}\label{sec:prior}
Given a set of values for model parameters, \textbf{FASE\_GLoBES.c} will obtain the corresponding oscillation-parameter values from \textbf{model-input.c}, and will pass these values to simulate the event spectrum and to give the prior value. Two gaussian prior functions are provided in \textbf{FASE} -- \texttt{FASE\_prior\_OSC} and \texttt{FASE\_prior\_model}. These two functions are for different purposes. If the user give the prior in oscillation (model) parameters, the user should register \texttt{FASE\_prior\_OSC} (\texttt{FASE\_prior\_model}) for the prior with the \textbf{GLoBES} function \texttt{glbRegisterPriorFunction}, as we introduced in the beginning of this section. The Gaussian prior is 
\begin{equation}\label{eq:prior}
\chi^2_{prior}=\sum_{i} \frac{(\theta_i-\theta^c_i)^2}{\sigma_i^2},
\end{equation}
 where $\theta_i$ is one of parameters constrained by prior, $\theta^c_i$ ($\sigma_c$) is the central value (Gaussian width) of the prior for $\theta_i$. We note that $\theta_i$ can be either model ($\vec{\theta}_{Model}$) or oscillation parameters ($\vec{\theta}_{OSC.}$).
 But, oscillation and model parameters can be mixed up together in the using of prior. 

The values of $\theta^c_i$ and $\sigma_i$ need to be given by the user through three arrays: \texttt{Central\_prior}, \texttt{UPPER\_prior}, and \texttt{LOWER\_prior}, in which there are six components. To treat asymmetry of width for the upper and lower Gaussian widths, we give values in two arrays \texttt{UPPER\_prior}, and \texttt{LOWER\_prior}, respectively. If the user gives the prior in model parameters, the order of each component follow with the setup of input of the probability engine. While the user gives the prior in oscillation parameters, the six components in order are $\theta_{12}$, $\theta_{13}$, $\theta_{23}$, $\delta$, $\Delta m_{21}^2$, and  $\Delta m_{31}^2$. The first four parameter are in \textbf{rad}, and the final two are in \textbf{eV$^2$}.

Finally, some restrictions are imposed by the studied flavour symmetry model. We set up these restrictions in the function \texttt{model\_restriction}, which is in \texttt{model-input\_diga.c} and \texttt{model-input.c}. In the function \texttt{model\_restriction}, the user needs to \textit{return $0$} once the restriction is broken. For example, if the normal ordering is imposed, we give ``\texttt{ if (DMS31<0) \{ return 1;\} } '' in \texttt{model\_restriction}, where \texttt{DMS31} is the variable for $\Delta m_{31}^2$. Then, when the restriction is broken, \texttt{model\_restriction} returns the value $1$ to the prior function \texttt{FASE\_prior\_OSC} or \texttt{FASE\_prior\_model}. In the following, the prior function will give $10^6$ for the $\chi^2$ value, and it will be selected out when the user studies the statistically reasonable region in the parameter space.  


\section{Constraint of model parameters}

The user can use \textbf{FaSE-GLoBES} to study the constraint of model parameters. Here we take tri-direct littlest seesaw as an example to present how we can adopt \textbf{FaSE-GLoBES} to constrain two model parameters -- $x$ and $\eta$. 
The $\chi^2$ function is constructed based on a log-likelihood ratio,
\begin{equation}\label{eq:chi-squared}
\chi^2(\vec{\theta},\xi_s,\xi_b)=2\sum_i\left(\eta_i(\vec{\theta},\xi_s,\xi_b)-n_i+n_i\ln\frac{n_i}{\eta_i(\vec{\theta},\xi_s,\xi_b)} \right)+p(\xi_s,\sigma_s)+p(\xi_b,\sigma_b)+\chi^2_{prior},
\end{equation}
where $i$ runs over the number of bins, $\eta_i{\vec{\theta},\xi_s,\xi_b}$ is the hypothesis event rate for bin i and $E_i$ is the central bin energy. The vector $\vec{\theta}$ consist test model or oscillation parameters. Here, $\vec{\theta}=(x,\eta,r,m_a)$. The parameters $\xi_s$ and $\xi_b$ are introduced to account for the systematic uncertainty of normalisation for the signal (subscript $_s$) and background (subscript $_b$) components for the event rate, and are allowed to bary in the fit as nuisance parameters. For a given hypothesized set of parmaeters $\vec{\theta}$, the event rate for bin $i$ is calculated as\\
\begin{equation}
\eta_i(\vec{\theta},\xi_s,\xi_b)=(1+\xi_s)\times n_i+(1+\xi_b)\times b_i,
\end{equation}
where $n_i$ and $b_i$ are the expected number of signal and background events in bin $i$, respectively. The nuisance parameters are constrained by the Gaussian prior $p(\xi,\sigma)=\xi^2/\sigma^2$ with corresponding uncertainties $\sigma_s$ and $\sigma_b$ for the signal and background, respectively. Finally, $\chi^2_{prior}$ is a set of Gaussian priors for hypothesis, and is expressed as Eq.~\ref{eq:prior}. 
To get the constraint of $x$ and $\eta$, we obtain the minimum of $\chi^2$ value,\vspace{0.2cm}\\
\texttt{
    glbSetProjection(free);\\
    float res0=glbChiNP(true\_values,NULL,GLB\_ALL);\\ } \vspace{0.2cm}\\
%
Then, we set two loops to get the $\Delta \chi^2$ value for different $x$ and $\eta$\vspace{0.2cm}\\
%
\texttt{     float x,eta,r,ma,dx,deta;\\
     float lower\_x,upper\_x,lower\_eta,upper\_eta;\\
     FILE* File=fopen("data/constraint\_x\_eta.dat", "w");\\
    lower\_x=-9; upper\_x=-3; lower\_eta=0.8*M\_PI; upper\_eta=2*M\_PI;\\
    dx=(upper\_x-lower\_x)/100; deta=(upper\_eta-lower\_eta)/100;\\
        glbSetProjection(projection);\\
   for (x=lower\_x;x<=upper\_x;x=x+dx)\{ \\
    for (eta=lower\_eta;eta<=upper\_eta;eta=eta+deta)\{\\
     glbSetOscParams(test\_values,x,0); glbSetOscParams(test\_values,eta,1);\\
        float res=glbChiNP(test\_values,NULL,GLB\_ALL);\\
            fprintf(File,"\%f \%f  \%f $\backslash$n",x,eta/M\_PI,res-res0);\\
                     \} fprintf(File,"$\backslash$n");\}\\
}

\begin{figure}[!h]
 \flushleft
\hspace{15mm}\includegraphics[width=0.32\textwidth]{figs/x_eta.pdf}$~~~~~~$\\
\hspace{15mm} \includegraphics[width=0.32\textwidth]{figs/x_r.pdf}\hspace{-11mm}
 \includegraphics[width=0.32\textwidth]{figs/eta_r.pdf}$~~~~~~$\\
\hspace{15mm} \includegraphics[width=0.32\textwidth]{figs/x_ma.pdf}\hspace{-11mm}
 \includegraphics[width=0.32\textwidth]{figs/eta_ma.pdf}\hspace{-11mm}
 \includegraphics[width=0.32\textwidth]{figs/r_ma.pdf}
 \caption{\label{fig:model_2D}Precision measurements of any two model parameters at 3$\sigma$ confidence level in the framework of three neutrino oscillations taking uncertainties of the current global fit results, for MOMENT, at $1\sigma$ (gray), $2\sigma$ (orange), $3\sigma$ (black). True values for the model parameters are used $(x,~\eta,~r,~M_a)=(-3.65,~1.13\pi,~0.511,~3.71~\text{meV})$.}
\end{figure}


We use the same code to obtain the constraint of any other combination of two parameters. Then, we can have the result as in Fig.~\ref{fig:model_2D}.


%\texttt{
%glbFreeParams(true\_values);\\
%glbFreeParams(test\_values); \\
%glbFreeParams(input\_errors); \\
%glbFreeParams(centers);\\
%glbFreeProjection(free);\\
%glbFreeProjection(projection);\\
%}



\section{Model testing}

We can also study on excluding the model, assuming different true values for oscillation parameters. In this example, we present testing the tri-driect littlest seesaw model in various $\theta_{23}$ and $\delta$. To do so, we set the true value in oscillation parameters. We change values of $\theta_{23}$ and $\delta$ of the true theory, and compute the minimal $\chi^2$ value for the tested model with all four model parameters, free to be varied. And, the studied statistics function is exactly Eq.~\ref{eq:chi-squared}, but the true event rate $n_i$ is predicted by a set of oscillation parameters, which will be varied in the code. And all four model parameter can be varied with the prior given by Eq.~\ref{eq:prior}.


The example code is given below.\vspace{0.2cm}\\
\texttt{ \{ ...  initalize the code ...\}\\
\{ ...  register the probability engine ...\}    }\vspace{0.2cm}\\
\texttt{    
    float degree   = M\_PI/180;\\
    float x\_true,eta\_true,r\_true,ma\_true;\\
    x\_true=-3.65029; eta\_true=1.13067*M\_PI; r\_true=0.511325; ma\_true=3.71199e-3;\\
    double M\_para[4],OSC\_para[6];\\
    M\_para[0]=x\_true; M\_para[1]=eta\_true; M\_para[2]=r\_true; M\_para[3]=ma\_true;\\
    MtoS(OSC\_para, M\_para);\\
    double th12\_true=OSC\_para[0];\\
    double th13\_true=OSC\_para[1];\\
    double th23\_true=OSC\_para[2];\\
    double dCP\_true=OSC\_para[3];\\
    double DM21\_true=OSC\_para[4];\\
    double DM31\_true=OSC\_para[5];\\
    glb\_params true\_values = glbAllocParams();\\
    glb\_params test\_values = glbAllocParams();\\
    glb\_params input\_errors = glbAllocParams();\\
    glb\_params centers = glbAllocParams();\\
    \\
    glbDefineParams(test\_values,x\_true,eta\_true,r\_true,ma\_true,0,0);\\
    glbSetDensityParams(test\_values,1.0,GLB\_ALL);\\
    glbDefineParams(true\_values,th12\_true,th13\_true,th23\_true,dCP\_true,DM21\_true,DM31\_true);\\
    glbSetDensityParams(true\_values,1.0,GLB\_ALL); }\vspace{0.2cm}\\
\texttt{ \{ ...  set up for prior ...\}}\vspace{0.2cm}\\
\texttt{
    float th23,dCP,dth23,ddCP,lower\_th23,upper\_th23,lower\_dCP,upper\_dCP;\\
    FILE* File=fopen("data/ModelTest\_th23\_dCP\_test.dat", "w");\\
    lower\_th23=40; upper\_th23=50; lower\_dCP=125; upper\_dCP=392;\\
    dth23=(upper\_th23-lower\_th23)/100; ddCP=(upper\_dCP-lower\_dCP)/100;\\
    glbSetProjection(free);\\
    for (th23=lower\_th23;th23<=upper\_th23;th23=th23+dth23)\{\\
    for (dCP=lower\_dCP;dCP<=upper\_dCP;dCP=dCP+ddCP)\{\\
    glbSetOscParams(true\_values,th23*degree,GLB\_THETA\_23);\\
    glbSetOscParams(true\_values,dCP*degree,GLB\_DELTA\_CP);\\
    PARA=STAN; \\
    glbSetOscillationParameters(true\_values);\\
    glbSetRates();\\
    PARA=MODEL;\\ 
        float res=glbChiNP(test\_values,NULL,GLB\_ALL);\\
            fprintf(File,"\%f \%f \%f $\backslash$n",th23,dCP,gsl\_cdf\_chisq\_Qinv(gsl\_cdf\_chisq\_Q(fabs(res),dof),1));\\
         \} fprintf(File,"$\backslash$n");\\
    \}
}\vspace{0.2cm}\\
\texttt{ \{ ...  destroy the pointer ...\}}\vspace{0.2cm}\\
Finally, in the code we adopt Wilk's theorem \cite{Wilks:1938dza}. When comparing nested models, the $\Delta \chi^2$ test statistics is a random variable asymptotically distributed according to the $\chi^2$-distribution with the number of degrees of freedom, which is equal to the difference in the number of free model parameters \texttt{dof}. Here the number \texttt{dof} is $2$. And that is our output: \texttt{gsl\_cdf\_chisq\_Qinv(gsl\_cdf\_chisq\_Q(fabs(res),dof),1)}.

\begin{figure}[!h]
 \flushleft
%
\includegraphics[width=0.32\textwidth]{figs/SR_th13_th23.pdf}$~~~~~~$\\
\includegraphics[width=0.32\textwidth]{figs/SR_th13_dCP.pdf}
\includegraphics[width=0.32\textwidth]{figs/SR_th23_dCP.pdf}$~~~~~~$\\
\includegraphics[width=0.32\textwidth]{figs/SR_th13_ldm.pdf}
\includegraphics[width=0.32\textwidth]{figs/SR_th23_ldm.pdf}
\includegraphics[width=0.32\textwidth]{figs/SR_dCP_ldm.pdf}
 \caption{\label{fig:SR_2D}The 2-D exclusion contour for tri-direct littlest seesaw model on the plane of any two true standard parameters, from $1\sigma$ to $5\sigma$. The range for each parameter is taken according to the $3\sigma$ uncertainty in NuFit4.0 results. The black dot denotes the best fit of NuFit4.0 results ($(\theta_{12},~\theta_{13},~\theta_{23},~\delta,~\Delta m_{21}^2,~\Delta m_{31}^2)=(33.82^\circ,~8.61^\circ,~49.6^\circ,~215^\circ,~7.39\times10^{-5}~\text{eV}^2,~2.525\times10^{-3}~\text{eV}^2)$), while the star is the prediction by the tri-direct littlest seesaw model with NuFit4.0 results ($(\theta_{12},~\theta_{13},~\theta_{23},~\delta,~\Delta m_{21}^2,~\Delta m_{31}^2)\sim(36.25^\circ,~8.63^\circ,~47^\circ,~279^\circ,~7.39\times10^{-5}~\text{eV}^2,~2.525\times10^{-3}~\text{eV}^2)$).}
\end{figure}

We use the same code to analysis the exclusion ability for other oscillation-parameter combinations. Then, we have the results shown in Fig.~\ref{fig:SR_2D}.

\section{Summary and conclusions}

We have presented \textbf{FaSE}, which is a supplemental simulation tool for \textbf{GLoBES} to study the flavour symmetry with neutrino oscillation experiments. \textbf{FaSE} provides \texttt{c}-codes: \textbf{model-input.c} and \textbf{FASE\_GLoBES.c}. Shown in Fig.~\ref{fig:FASE}, \textbf{FASE\_GLoBES}, which calls functions in \textbf{model-input.c}, plays a role as a bridge between \textbf{FaSE} and \textbf{GLoBES} to simulate the expected spectra and compute the prior value. It can be left to be untouched by users. However, all inputs of the user needs to be given in the code \textbf{model-input.c}. Given a set of model parameters $\vec{M}$, with \textbf{GLoBES}, the output can be the $\chi^2$ value for the hypothesis $\vec{M}$. {\color{red}\texttt{Makefile} is easy to include these two binary files (\textbf{model-input} and \textbf{FASE\_GLoBES}) in the \texttt{makefile} script for \textbf{GLoBES}. }

We also present two examples for \textbf{FaSE-GLoBES} with the flavour symmetry model -- tri-direct littlest seesaw (TDLS) -- and the future neutrino oscillaiton experiment -- MOMENT. We show the model can be assign in two ways: the relation between model and oscillation parameters or the form of mass matrix in model parameters. The input of the oscillation probability and prior value can be in model or oscillation parameters. We further demonstrate how to use \textbf{FaSE-GLoBES} to obtain the constraint of any two of model parameters, and to study the ability to TDLS by MOMENT experiment. 

Finally, \textbf{GLoBES} is a popular and powerful simulation tool to analysis the neutrino oscillation experiments in a simple language (AEDL), without losing too much detail. Considering the success of the flavour symmetry theory to explain the neutrino oscillations, \textbf{FaSE-GLoBES} should benefit model builders of leptonic flavour symmetry and phenomenologists for neutrino oscillation physics. We leave the flexibility for the user, and some other improvements and extensions might be done in the future.
 

% BIBLIOGRAPHY
% use BIBTEX if you want
\bibliographystyle{JHEP}
%\bibliographystyle{plain}
\bibliography{FAS-GLoBES.bib}
\end{document}
